name: autofix

on:
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

jobs:
  autofix:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install stable Rust (with rustfmt)
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt

      - name: Install Taplo (TOML formatter)
        uses: uncenter/setup-taplo@v1
        with:
          version: "0.8.1"

      # --- 1. Detect CR-only line endings (BEFORE conversion) ---
      - name: Debug newline bytes (Cargo.toml)
        run: |
          set -euo pipefail
          python3 - <<'PY'
          from pathlib import Path
          p = Path("Cargo.toml")
          if p.exists():
              data = p.read_bytes()
              nl = data.count(b'\n')
              cr = data.count(b'\r')
              print(f"Cargo.toml: \\n = {nl}, \\r = {cr}")
              if cr > 0 and nl == 0:
                  print("⚠️  DETECTED: Classic Mac CR-only line endings!")
              elif cr > 0 and nl > 0:
                  print("⚠️  DETECTED: Mixed line endings (CRLF or partial CR)")
              else:
                  print("✅ Line endings look normal (LF only)")
              print("First 120 bytes (hex):", data[:120].hex())
          else:
              print("⚠️  Cargo.toml not found")
          PY

      # --- 2. Convert CR-only → LF (tracked files only) ---
      - name: Convert CR-only line endings to LF (tracked files)
        id: convert
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import subprocess
          from pathlib import Path

          TEXT_EXT = {".rs",".toml",".yml",".yaml",".md",".txt",".json",".lock"}
          ALWAYS = {"Cargo.toml","Cargo.lock",".gitattributes","README.md"}

          out = subprocess.check_output(["git","ls-files","-z"])
          files = [p for p in out.split(b"\0") if p]

          changed = []
          for b in files:
              p = Path(b.decode("utf-8", "surrogateescape"))
              if p.name in ALWAYS or p.suffix.lower() in TEXT_EXT:
                  try:
                      data = p.read_bytes()
                      # Detect classic Mac: has \r but zero \n
                      if b"\r" in data and b"\n" not in data:
                          p.write_bytes(data.replace(b"\r", b"\n"))
                          changed.append(str(p))
                  except Exception as e:
                      print(f"⚠️  Skipping {p}: {e}")

          print(f"\n✅ Converted {len(changed)} file(s) from CR-only to LF")
          for x in sorted(changed)[:200]:
              print(" -", x)
          
          # Output count for next steps
          with open(Path.home() / "convert_count.txt", "w") as f:
              f.write(str(len(changed)))
          PY

      # --- 3. Verify .gitattributes exists (fail fast if missing) ---
      - name: Verify .gitattributes exists and enforces LF
        run: |
          set -euo pipefail
          if [ ! -f .gitattributes ]; then
            echo "::error::.gitattributes not found! Please create it with: * text=auto eol=lf"
            exit 1
          fi
          if ! grep -q 'text=auto eol=lf' .gitattributes; then
            echo "::error::.gitattributes exists but doesn't enforce LF. Please add: * text=auto eol=lf"
            exit 1
          fi
          echo "✅ .gitattributes verified"

      # --- 4. Apply git renormalization (CRLF↔LF) ---
      - name: Normalize line endings (LF)
        run: |
          set -euo pipefail
          git add --renormalize . || true
          echo "After renormalize:"
          git status --porcelain || true

      # --- 5. Apply formatters ---
      - name: Rustfmt (apply)
        run: cargo fmt

      - name: Taplo fmt (apply)
        run: taplo fmt

      # --- 6. Stage ALL changes explicitly ---
      - name: Stage changes
        run: git add -A

      # --- 7. Final verification (FAIL if no changes) ---
      - name: Final debug summary
        id: verify
        run: |
          set -euo pipefail
          echo "=== Final Git status ==="
          git status --porcelain
          echo ""
          echo "=== Final Git diff stat (cached) ==="
          git diff --cached --stat
          echo ""
          echo "=== Cargo.toml newline check (post-fix) ==="
          python3 - <<'PY'
          from pathlib import Path
          p = Path("Cargo.toml")
          if p.exists():
              data = p.read_bytes()
              print(f"Cargo.toml: \\n = {data.count(b'\\n')}, \\r = {data.count(b'\\r')}")
          PY
          
          # Count changed files
          CHANGED=$(git status -s | wc -l)
          CONVERT_COUNT=$(cat $HOME/convert_count.txt 2>/dev/null || echo "0")
          
          echo ""
          echo "=== Summary ==="
          echo "Files converted (CR→LF): $CONVERT_COUNT"
          echo "Total git changes: $CHANGED"
          
          if [ "$CHANGED" -eq 0 ]; then
            echo "::warning::No changes detected after conversion + formatting"
            echo "This means either:"
            echo "  1. Files don't have CR-only line endings"
            echo "  2. Files are already clean"
            echo "  3. Conversion step didn't run"
            # Don't fail here, let create-pull-request handle it gracefully
          fi

      # --- 8. Create PR if changes exist ---
      - name: Create PR
        uses: peter-evans/create-pull-request@v6
        with:
          commit-message: "chore: fix CR-only line endings + formatting"
          title: "chore: fix CR-only line endings + formatting"
          body: |
            Automated fixes:
            - Converted classic Mac CR-only line endings → LF
            - Applied git renormalization (.gitattributes)
            - cargo fmt + taplo fmt

            This resolves GitHub Raw showing files as "1 line".
          branch: autofix/formatting
          delete-branch: true
          add-paths: |
            *

